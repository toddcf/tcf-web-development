<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap" rel="stylesheet">

  <!-- CSS -->
  <link rel="stylesheet" type="text/css" href="../assets/css/martech-min.css">

  <title>MarTech | Shadow DOM Click Tracking</title>

  <meta name="Author" content="Todd Croak-Falen">
  <meta name="Description" content="MarTech shadow DOM click tracking.">

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
  <link rel="manifest" href="../manifest.json">
  <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="../favicon.ico">
  <meta name="msapplication-config" content="browserconfig.xml">
  <meta name="theme-color" content="#ffffff">

</head>

<body class="body">

  <div class="body__project-container">

    <h1>Shadow DOM Click Tracking</h1>

    <h2>Overview</h2>

    <p>The overall architecture is this:</p>

    <ol>
      <li>
        <p>When the page loads, crawl it and collect any shadow DOMs that exist.</p>
      </li>
      <li>
        <p>For each shadow DOM that is found, attach a 'click' event listener to its shadowRoot.</p>
      </li>
      <li>
        <p>If a click is detected by this event listener, determine what the clicked element was and standardize it to the type of object that your Global Clicks/Events rule (for regular DOM clicks) expects.</p>
      </li>
      <li>
        <p>Manually trigger your Global Clicks/Events rule, and send it the standardized object you created.</p>
      </li>
    </ol>

    <h2>Shadow DOM Data Element (‘shadow doms’)</h2>

    <p>First, create a data element called 'shadow doms'. Select 'Custom Code'. Then paste in this snippet:</p>

<pre><code>
return [...document.getElementsByTagName('*')].filter(tag => !!tag.shadowRoot);
</code></pre>

    <p>That's all the code you need for the data element!</p>

    <h3>Explanation</h3>

    <ol>
      <li>
        <p><code>document.getElementsByTagName('*')</code> gets all tags on the page.</p>
      </li>
      <li>
        <p>However, that returns an HTMLCollection. Convert it to an array by wrapping it inside <code>[...]</code>.</p>
      </li>
      <li>
        <p>Now that you have an array, you can call the <code>.filter</code> method on it.</p>
      </li>
      <li>
        <p>Inside the <code>.filter</code> method, <code>(tag => !!tag.shadowRoot)</code> checks each tag in the array.
          If a tag contains <code>shadowRoot</code>, then that tag represents a shadow DOM, and the filter will include
          it. (If not, the filter will ignore that tag.)</p>
      </li>
      <li>
        <p><code>return</code> all of this because your data element needs to return a value. You now have a new array
          made up only of the shadow DOM tags that were filtered out of the entire page. (If none were found, it will
          return an empty array.)</p>
      </li>
    </ol>

    <h3>How to Use the <b>shadow doms</b> Data Element</h3>

    <p>Executing <code>_satellite.getVar('shadow doms');</code> will return an array containing all shadow DOMs found on the page. (If none are found, it will return an empty array.)</p>

    <p>We're going to be using this data element in a separate Adobe Launch rule that listens for clicks in any shadow DOMs.</p>

    <h2>Shadow DOM “Add Event Listener” Rule</h2>

    First, the full code block for context. Scroll past it for a breakdown of what it does.

<pre><code>
const shadowDOMs = _satellite.getVar('shadow doms');

const shadowClicks = (e) => {
  const clickData = {
    shadowClick: true,
    clickedElement: '',
  };
  
  if (!!e.target) {
    if (e.target instanceof SVGElement) {
      if (!!e.target.getAttribute('d')) {
        clickData.clickedElement = e.target.parentNode.parentNode; // Handles clicks on path elements *inside* SVG tags -- has to go up two levels. This condition must be nested *inside the "instanceof SVGElement" condition*, as that will also be true.
      } else {
        clickData.clickedElement = e.target.parentNode; // Handles clicks on SVG tags.
      }
    } else {
      clickData.clickedElement = e.target; // All other clicks (non-SVG).
    }
  }
  
  if (!!clickData.clickedElement) {
    _satellite.track('set-global-click-or-event-variables', clickData);
    _satellite.track('send-global-click-or-event-beacon');
  }
}

if (!!shadowDOMs && Array.isArray(shadowDOMs) && shadowDOMs.length > 0) {
  shadowDOMs.forEach(shadowDOM => {
    shadowDOM.shadowRoot.addEventListener('click', shadowClicks);
  });
}
</code></pre>

  <h3>Explanation</h3>

  <ol>
    <li>
      <p>The first thing we do is grab the <code>shadow doms</code> data element we just created and store it in a variable called <code>shadowDOMs</code>: <code>const shadowDOMs = _satellite.getVar('shadow doms');</code></p>
    </li>
    <li>
      <p>Then, for the purposes of this explanation, let's skip down to the end of the file and set up our event listener. First, some validation to make sure that <code>shadowDOMs</code> exists, that it is an array, and that this array contains at least one item: <code>if (!!shadowDOMs && Array.isArray(shadowDOMs) && shadowDOMs.length > 0)</code>. This is important because if no shadow DOMs exist on the page .&nbsp;.&nbsp;. you don't want the rest of this code block to execute and start throwing errors.</p>
    </li>
    <li>
      <p>Now that we're certain that <code>shadowDOMs</code> is an array containing at least one item, we are safe to run the <code>.forEach</code> method on it. And for each shadow DOM in the array, we attach a 'click' listener to its <code>shadowRoot</code>.  And when a click on this <code>shadowRoot</code> is detected, we set it to invoke a function called <code>shadowClicks</code>. (We haven't written that function yet &mdash; that's next.)</p>
    </li>
    <li>
      <p>Okay, now that we're listening for a function called <code>shadowClicks</code>, it's time to create that function. Scroll back up and create it <em>prior</em> to the listener. And we're going to take in the parameter <code>e</code> for the click event: <code>const shadowClicks = (e) => {};</code></p>
    </li>
    <li>
      <p>Inside the brackets of this function, the first thing we're going to do is create an object called <code>clickData</code>. This object will later be passed to our Global Clicks / Events rule. It is going to simulate the clicked element as if it occured in the regular DOM. But for now, all you have to do is write <code>const clickData = {};</code></p>
    </li>
    <li>
      <p>Inside the <code>clickData</code> object, add the property: <code>shadowClick: true,</code>. (Note that <code>true</code> is a Boolean, not a string. End the line with a comma.) This flag will come in handy once this object is received by your Global Clicks/Events rule and you want to differentiate between regular DOM clicks and shadow DOM clicks. For now, let's not go down this rabbit hole.</p>
    </li>
    <li>
      <p>On the next line inside the same <code>clickData</code> object, add the property: <code>clickedElement: '',</code>. (We default it to an empty string. We also end this line with a comma. That way, in case we ever add another property after this one in the future, we don't forget to add the comma at that point. Or, when we do add the comma at the time we're adding another property, it doesn't create an additional line of changed code to be reviewed in your pull request.)</p>
    </li>
    <li>
      <p>Now it's time to write the logic that will determine what element in the shadow DOM got clicked. This will typically involve the <code>target</code> in the click event (the <code>e</code> parameter this function takes in). Therefore, before we go any further, let's add some validation to make sure it exists: <code>if (!!e.target)</code></p>
    </li>
    <li>
      <p>Inside this code block, there is a specific use case we have to check for: What if the clicked element is an SVG? If you don't account for this, then any time a user clicks an SVG, the <code>clickData</code> object that you pass to your Global Clicks/Events rule is going to be a mess. So add the following condition: <code>if (e.target instanceof SVGElement)</code></p>
    </li>
    <li>
      <p>It gets more complex. There are a couple use cases for SVG elements getting clicked. The user may have clicked on the SVG tag itself, or they may have clicked on the path elements <em>inside</em> the SVG tag. First we'll handle the path elements by nesting yet another condition inside our SVG condition: <code>if (!!e.target.getAttribute('d'))</code></p>
    </li>
    <li>
      <p>Inside the code block we just created for SVG path element clicks, we will look two parentNodes up from the path element, then store it in our <code>clickData</code> object: <code>clickData.clickedElement = e.target.parentNode.parentNode;</code></p>
    </li>
    <li>
      <p>Then we can add an <code>else</code> condition to handle the clicks directly on the SVG tags. Inside this condition, we only have to go up <em>one</em> <code>parentNode</code>: <code>clickData.clickedElement = e.target.parentNode;</code></p>
    </li>
    <li>
      <p>We're done with SVGs, so let's exit the <code>(e.target instanceof SVGElement)</code> code block and add an <code>else</code> condition to handle all other non-SVG clicks. Inside, we can just do this: <code>clickData.clickedElement = e.target;</code></p>
    </li>
    <li>
      <p>Now the clicked element (if it exists) has been selected and we are ready to pass it to our Global Clicks/Events rule. For safety, we'll start with some validation to confirm that a clicked element was found before we go so far as to send it: <code>if (!!clickData.clickedElement)</code></p>
    </li>
    <li>
      <p>Inside this condition, we'll first trigger our Global Clicks/Events rule that sets variables, and we'll pass our <code>clickData</code> object into it: <code>_satellite.track('set-global-click-or-event-variables', clickData);</code>. Our Global Clicks/Events rule will take it from here. (See my article on Global Click/Events for this logic.)</p>
    </li>
    <li>
      <p>Then we'll also trigger our Global Clicks/Events rule that sends the beacon and clears the variables: <code>_satellite.track('send-global-click-or-event-beacon');</code> (Once again, see my article on Global Clicks/Events for an explanation on this architecture.)</p>
    </li>
  </ol>

  <p></p>

  </div> <!-- Close .body__project-container -->

</body>

</html>