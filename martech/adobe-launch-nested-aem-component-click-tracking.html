<!doctype html><html lang=en><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><link href=https://use.fontawesome.com/releases/v5.8.1/css/all.css rel=stylesheet crossorigin=anonymous integrity=sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap" rel=stylesheet><link href=../assets/prism/prism-okaidia-1.29.0.css rel=stylesheet><link href=../assets/css/global-min.css rel=stylesheet><link href=../assets/css/text-min.css rel=stylesheet><link href=../assets/css/nav-min.css rel=stylesheet><link href=../assets/css/headings-min.css rel=stylesheet><link href=../assets/css/martech-article-min.css rel=stylesheet><link href=../assets/css/footer-min.css rel=stylesheet><title>MarTech | Adobe Launch Nested AEM Component Click Tracking</title><meta content="Todd Croak-Falen" name=Author><meta content="MarTech Adobe Launch Nested AEM Component Click Tracking." name=Description><link href=../apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=../favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=../favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=../manifest.json rel=manifest><link href=../safari-pinned-tab.svg rel=mask-icon color=#5bbad5><link href=../favicon.ico rel="shortcut icon"><meta content=browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><body class="body line-numbers"><div class=body__project-container><nav class=nav><div class="content__center content__center_1140 nav__flex"><a class="font_size_1 nav__flex_link" href=/ ><div class=nav__flex_text><i class="fas fa-home nav__flex_icon"></i>Home</div></a><a class="font_size_1 nav__flex_link" href=../about-me><div class=nav__flex_text><i class="fas nav__flex_icon fa-user-circle"></i>About Me</div></a></div></nav><main class="content-top main"><header class=header><div class="heading heading_theme_clear"><div class=heading__title-overflow><h1 class="heading__title-tag font_size_4"><span class=heading__title-tag_title>Adobe Launch Nested AEM Component Click Tracking</span></h1></div></div><div class="martech-header__img martech-header__img_waterfall-cascade"></div></header><section><div class="heading heading_theme_black"><div class=heading__title-overflow><h2 class="heading__title-tag font_size_3"><span class=heading__title-tag_title>Overview</span></h2></div></div><div class="content__center content__center_700"><div class=content__block><p class="font_size_body main__text">When my company began using AEM Components, it was the MarTech team’s job to implement click tracking on those components. We already had global click tracking in place that would take the <code class="font_size_body code__snippet">data-track-noun</code> and <code class="font_size_body code__snippet">data-track-verb</code> attributes, concatenate them, and delimit them with a colon. But this was going to require additional complexity.<p class="font_size_body main__text">For starters, the AEM Components were going to be nested inside each other. There could be several layers of nesting. And when a component was clicked, we were going to want to concatenate the click tracking values of the parent components all the way down to the child that was clicked.<p class="font_size_body main__text">For example, the Careers page has three sections:<ol class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Employment<li class=content__block_li><p class="font_size_body main__text">Apprenticeships<li class=content__block_li><p class="font_size_body main__text">Internships</ol><p class="font_size_body main__text">Within each of these sections there is a set of cards, each representing a category. For example, the “Employment” section contains these cards:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Administration<li class=content__block_li><p class="font_size_body main__text">Research & Development<li class=content__block_li><p class="font_size_body main__text">Sales<li class=content__block_li><p class="font_size_body main__text">Installation & Repair<li class=content__block_li><p class="font_size_body main__text">Support</ul><p class="font_size_body main__text">And each card contains two buttons:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Learn More<li class=content__block_li><p class="font_size_body main__text">View Jobs</ul><p class="font_size_body main__text">If a user clicks a “Learn More” button and all I pass is <code class="font_size_body code__name">learn-more</code>, that won’t tell our analysts much about which careers are getting the most clicks. Instead, they want values like:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">employment:research-development:learn-more<li class=content__block_li><p class="font_size_body main__text">employment:installation-repair:view-jobs<li class=content__block_li><p class="font_size_body main__text">employment:administration:learn-more</ul><p class="font_size_body main__text">This was going to require more than just the standard two <code class="font_size_body code__snippet">data-track-noun</code> and <code class="font_size_body code__snippet">data-track-verb</code> attributes.</div></div><div class="heading heading_theme_clear"><div class=heading__title-overflow><h3 class="heading__title-tag font_size_2"><span class=heading__title-tag_title>Solution</span></h3></div></div><div class="content__center content__center_700"><div class=content__block><p class="font_size_body main__text">I decided that we could add a <code class="font_size_body code__snippet">data-track-component-level-X</code> attribute, with <code class="font_size_body code__snippet">X</code> being a number. (These would have to be set dynamically, because we would never know how many levels a given component was going to be nested.)<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">data-track-component-level-1="employment"<li class=content__block_li><p class="font_size_body main__text">data-track-noun="research-development"<li class=content__block_li><p class="font_size_body main__text">data-track-verb="learn-more"</ul><p class="font_size_body main__text">The three (or more) of those would then be concatenated, in the correct order, and only if they exist. Since there could be multiple levels of parent components, we could potentially wind up with <code class="font_size_body code__snippet">data-track-component-level-1</code>, <code class="font_size_body code__snippet">2</code>, <code class="font_size_body code__snippet">3</code>, etc.<p class="font_size_body main__text">The question was how to add these attributes to each AEM Component. Our Content team did not have the bandwidth to add each one manually. Furthermore, AEM Components might be nested in a multitude of ways, and those ways might be changed on the fly. If each such change involved the complete reauthoring of every AEM Component’s tracking attributes, the scope of each change would become unwieldy, and the opportunity for mistakes would increase.<p class="font_size_body main__text">Therefore, it was decided that these values would be set programmatically. We came up with a two-pronged approach. The first prong was on the AEM side, which would be handled by the Content team:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Each AEM Component would be given a <code class="font_size_body code__snippet">data-track-component-type</code> attribute. Its value would represent the type of component: <code class="font_size_body code__snippet">header</code>, <code class="font_size_body code__snippet">footer</code>, <code class="font_size_body code__snippet">breadcrumb</code>, <code class="font_size_body code__snippet">crowdriff</code>, etc. (This is so we will know which elements to treat as AEM Components.)<li class=content__block_li><p class="font_size_body main__text">Values from heading tags, link text, etc. are programmatically copied into <code class="font_size_body code__snippet">data-track-verb</code> attributes.<li class=content__block_li><p class="font_size_body main__text">Each of these values would get programmatically standardized into lowercase kebab-case.</ul><p class="font_size_body main__text">The second prong would be handled by the MarTech team, via Adobe Launch:<ol class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">On each page/route load, an Adobe Launch rule would fire that would crawl the page. If it found any elements containing a <code class="font_size_body code__snippet">data-track-component-type</code> attribute, it would collect its tracking attributes.<li class=content__block_li><p class="font_size_body main__text">Then it would check the next layer of children for that element. If any contained a <code class="font_size_body code__snippet">data-track-component-type</code> attribute, the tracking attributes from the parent element would be added to the tracking attributes of the child element using the <code class="font_size_body code__snippet">data-track-component-level-X</code> attribute.<li class=content__block_li><p class="font_size_body main__text">The process would repeat for the children of that child, until no more children were found. Depending on how many layers of nesting there were for the AEM Components, this is where we might wind up with <code class="font_size_body code__snippet">data-track-component-level-1</code>, <code class="font_size_body code__snippet">data-track-component-level-2</code>, <code class="font_size_body code__snippet">data-track-component-level-3</code>, etc.<li class=content__block_li><p class="font_size_body main__text">Once an element has been modified, the Launch rule would set a flag on it so we know it's been handled. That way, if more AEM Components got added to the page after the initial page load and our rule needed to crawl the page again, it could skip modifying the components it already modified in the previous pass.</ol><p class="font_size_body main__text">Then, the MarTech team would have to modify the <code class="font_size_body code__name">Global | Set Variables | Clicks or Events #25</code> rule. Currently, that rule only checked for <code class="font_size_body code__snippet">data-track-noun</code> and <code class="font_size_body code__snippet">data-track-verb</code> and concatenated the two. Now it would have to factor in any number of <code class="font_size_body code__snippet">data-track-component-level-X</code> attributes at the beginning of that concatenation. (For an explanation on how that was accomplished, see my article on <a class="link link_theme_black" href=adobe-launch-global-clicks-or-events-tracking>Adobe Launch Global Clicks or Events Tracking</a>.)<p class="font_size_body main__text">But to see how the programming was done for the AEM Component attributes, keep reading.</div></div></section><section><div class="heading heading_theme_black"><div class=heading__title-overflow><h2 class="heading__title-tag font_size_3"><span class=heading__title-tag_title>‘Global | Set AEM Component Data Attributes’ Rule</span></h2></div></div><div class="content__center content__center_700"><div class=content__block><p class="font_size_body main__text">We created an Adobe Launch rule named <code class="font_size_body code__name">Global | Set AEM Component Data Attributes</code>. Here’s the full syntax for context. (Scroll past it for an explanation on how each part works.)</div></div><div class="content__center content__center_1440"><div class=content__block><pre class=code__block><code class=language-javascript>const aemComponentTracking = {
  setTrackingAttributes: (currentElement, mergedTrackingAttributesArr) => {
    mergedTrackingAttributesArr = (!!mergedTrackingAttributesArr && Array.isArray(mergedTrackingAttributesArr)) ? mergedTrackingAttributesArr : [];

    const numberOfValues = mergedTrackingAttributesArr.length;
    if (!!currentElement && numberOfValues > 0) {
      if (numberOfValues === 1) {
        currentElement.removeAttribute('data-track-noun');
      }

      mergedTrackingAttributesArr.forEach((trackingAttribute, i) => {
        switch (i) {
          case numberOfValues - 1:
            currentElement.setAttribute('data-track-verb', trackingAttribute);
            break;
          case numberOfValues - 2:
            currentElement.setAttribute('data-track-noun', trackingAttribute);
            break;
          default:
            currentElement.setAttribute(`data-track-component-level-${i + 1}`, trackingAttribute);
        }
      });
      currentElement.setAttribute('data-track-component-attributes-set', 'true');
    }
    aemComponentTracking.checkChildren(currentElement, mergedTrackingAttributesArr);
  },
  uniqueValue(arr, str) {
    let unique = true;
    if (!!arr && Array.isArray(arr) && arr.length > 0 && !!str && arr.includes(str)) {
      unique = false;
    }
    return unique;
  },
  mergeTrackingAttributes: (currentElement, existingTrackingAttributes, parentTrackingAttributes) => {
    existingTrackingAttributes = (!!existingTrackingAttributes && Array.isArray(existingTrackingAttributes)) ? existingTrackingAttributes : [];
    parentTrackingAttributes = (!!parentTrackingAttributes && Array.isArray(parentTrackingAttributes)) ? parentTrackingAttributes : [];
    mergedTrackingAttributesArr = [];

    const mergedTrackingAttributesArrPusher = (arr) => {
      if (!!arr && Array.isArray(arr) && arr.length > 0) {
        arr.forEach(arrItem => {
          if (aemComponentTracking.uniqueValue(mergedTrackingAttributesArr, arrItem)) {
            mergedTrackingAttributesArr.push(arrItem);
          }
        });
      }
    }

    mergedTrackingAttributesArrPusher(parentTrackingAttributes);
    mergedTrackingAttributesArrPusher(existingTrackingAttributes);

    aemComponentTracking.setTrackingAttributes(currentElement, mergedTrackingAttributesArr);
  },
  getTrackingAttributes: (currentElement, parentTrackingAttributes) => {
    parentTrackingAttributes = (!!parentTrackingAttributes && Array.isArray(parentTrackingAttributes)) ? parentTrackingAttributes : [];
    const existingTrackingAttributes = [];

    let level = 1;
    let parentComponentLevelX = '';
    do {
      parentComponentLevelX = currentElement.getAttribute(`data-track-component-level-${level}`);
      if (!!parentComponentLevelX) {
        existingTrackingAttributes.push(parentComponentLevelX);
      }
      level++;
    } while (!!currentElement.getAttribute(`data-track-component-level-${level}`));

    const dataTrackNoun = currentElement.getAttribute('data-track-noun');
    if (!!dataTrackNoun && dataTrackNoun !== 'no-title') {
      existingTrackingAttributes.push(dataTrackNoun);
    }

    const dataTrackVerb = currentElement.getAttribute('data-track-verb');
    if (!!dataTrackVerb && dataTrackVerb !== 'no-title') {
      existingTrackingAttributes.push(dataTrackVerb);
    }

    const dataTrackComponentAttributesSet = currentElement.getAttribute('data-track-component-attributes-set');
    if (
      !!dataTrackComponentAttributesSet &&
      dataTrackComponentAttributesSet === 'true'
    ) {
      aemComponentTracking.checkChildren(currentElement, existingTrackingAttributes);
    } else {
      aemComponentTracking.mergeTrackingAttributes(currentElement, existingTrackingAttributes, parentTrackingAttributes);
    }
  },
  checkChildren: (currentElement, parentTrackingAttributes) => {
    let currentElementChildren;
    parentTrackingAttributes = (!!parentTrackingAttributes && Array.isArray(parentTrackingAttributes)) ? parentTrackingAttributes : [];

    if (!!currentElement) {
      currentElementChildren = currentElement.children;
      if (!!currentElementChildren && currentElementChildren.length > 0) {
        currentElementChildren = [...currentElementChildren];
        if (Array.isArray(currentElementChildren)) {
          currentElementChildren.forEach(currentElementChild => {
            if (
              currentElementChild.hasAttribute('data-track-component-type') ||
              !!['A', 'BUTTON'].includes(currentElementChild.tagName)
            ) {
              aemComponentTracking.getTrackingAttributes(currentElementChild, parentTrackingAttributes);
            } else {
              aemComponentTracking.checkChildren(currentElementChild, parentTrackingAttributes);
            }
          });
        }
        // NOTE: If there were no children, do nothing (stop).
      }
    }
  },
  init: () => {
    if (
      !!window && !!window.document && !!window.document.body &&
      !!window.document.body.querySelector('[data-track-component-type]')
    ) {
      aemComponentTracking.checkChildren(window.document.body);
    }

    const shadowDOMs = _satellite.getVar('shadow doms');
    if (!!shadowDOMs && Array.isArray(shadowDOMs) && shadowDOMs.length > 0) {
      shadowDOMs.forEach((shadowDOM) => {
        if (!!shadowDOM.querySelector('[data-track-component-type]')) {
          aemComponentTracking.checkChildren(shadowDOM);
        }
      });
    }
  },
}

aemComponentTracking.init();</code></pre></div></div><div class="heading heading_theme_clear"><div class=heading__title-overflow><h3 class="heading__title-tag font_size_2"><span class=heading__title-tag_title>Explanation</span></h3></div></div><div class="content__center content__center_700"><div class=content__block><p class="font_size_body main__text">The entire rule is written as an object literal (<code class="font_size_body code__snippet">const aemComponentTracking = {}</code>), so each method inside that object is declared prior to any other methods that will call it. Therefore, this explanation will work from the bottom up.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Line 131: On the last line of code, <code class="font_size_body code__snippet">aemComponentTracking.init()</code> is invoked.<li class=content__block_li><p class="font_size_body main__text">Lines 112 - 128: <code class="font_size_body code__snippet">init</code> method:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Lines 113 - 118: The first thing <code class="font_size_body code__snippet">init</code> does is check the regular DOM.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Line 115: To reduce performance drag, a quick check is done to make sure there is at least one AEM Component on the page. If there is not, we don’t crawl the DOM.<li class=content__block_li><p class="font_size_body main__text">Line 117: Take the first layer of the DOM (<code class="font_size_body code__snippet">window.document.body</code>) and pass it into the <code class="font_size_body code__snippet">checkChildren</code> method.</ul><li class=content__block_li><p class="font_size_body main__text">Lines 120 - 127: Next, <code class="font_size_body code__snippet">init</code> does the same thing to any shadow DOMs that may exist on the page. (See my article on <a class="link link_theme_black" href=adobe-launch-shadow-dom-click-tracking></a> for details on this architecture.)</ul><li class=content__block_li><p class="font_size_body main__text">Lines 88 - 111: <code class="font_size_body code__snippet">checkChildren</code> method. All this method does is check if the current element has children. If so, it decides which method to call on each one.<li class=content__block_li><p class="font_size_body main__text">Lines 88 - 90: The <code class="font_size_body code__snippet">checkChildren</code> method takes in the current element. Optionally, it can also take in any parent tracking attributes that get passed into it, but those are not a given. For example, on Line 90, it defaults this value to an empty array if none was passed in. And since this first pass is on the top level of the DOM or shadow DOM, there are no parent tracking attributes to pass in yet.<li class=content__block_li><p class="font_size_body main__text">Line 93: Generate a list of children one DOM level down — but no deeper than that. (At each layer, we have to perform quite a few potential actions before moving down another layer deeper.)<li class=content__block_li><p class="font_size_body main__text">Line 94: Check to see if at least one child was found. (If not, we skip this entire code block and do nothing — we have reached the end of this portion of the DOM tree.)<li class=content__block_li><p class="font_size_body main__text">Line 95 - 107: If at least one child was found, check each child to see if it is an AEM Component, a button, or an anchor tag.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Line 102: For each item that meets this criteria, invoke the <code class="font_size_body code__snippet">getTrackingAttributes</code> method and pass this item into it. If any parent tracking attributes exist, pass those in, too.<li class=content__block_li><p class="font_size_body main__text">Line 104: For each item that does <em>not</em> meet the criteria, simply invoke the <code class="font_size_body code__snippet">checkChildren</code> method on it recursively without getting or setting any attributes. (Just because this child is not an AEM Component, a button, or a link, does not mean that these types of elements will not be nested beneath it, so we must keep drilling down.)</ul><li class=content__block_li><p class="font_size_body main__text">Lines 54 - 87: <code class="font_size_body code__snippet">getTrackingAttributes</code> method. As the name implies, this method only <em>gets</em> the existing tracking attributes on an element. (It does not start merging them with any parent tracking attributes yet — that will be handled by a separate method.)<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Line 56: An empty array is created to collect any applicable existing tracking attributes.<li class=content__block_li><p class="font_size_body main__text">Lines 58 - 66: First, any <code class="font_size_body code__snippet">data-track-component-level-X</code> attribute values that exist are collected in numerical order and pushed into the <code class="font_size_body code__snippet">existingTrackingAttributes</code> array. Since we don’t know how many (if any) there will be, a do while loop is used.<li class=content__block_li><p class="font_size_body main__text">Lines 68 - 71: Next, if a <code class="font_size_body code__snippet">data-track-noun</code> attribute exists, push that value in. (Note that there are use cases where this value may have been set to <code class="font_size_body code__snippet">"no-title"</code> if the AEM Component was just a container and did not have anything of substance to be included in the click tracking. So we filter those out on Line 69.)<li class=content__block_li><p class="font_size_body main__text">Lines 73 - 76: Next, the same actions are performed for <code class="font_size_body code__snippet">data-track-verb</code>.<li class=content__block_li><p class="font_size_body main__text">Lines 78 - 86: If this is not the first pass that this rule is making on the page (for example, if more AEM Components were added after the page loaded), then a flag will have been set to prevent our code from needlessly refactoring the same attributes on the AEM Components that were already handled in the previous pass. This flag is the <code class="font_size_body code__snippet">data-track-component-attributes-set="true"</code> attribute.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Line 83: If this attribute is found, we don’t need to do any merging or setting of attributes. Instead, we just invoke the <code class="font_size_body code__snippet">checkChildren</code> method on it and pass in the current element plus the existing tracking attributes we just collected, as they may need to get merged in with any child element tracking attributes if necessary.<li class=content__block_li><p class="font_size_body main__text">Line 85: If the current element’s attributes have <em>not</em> already been merged, we invoke the <code class="font_size_body code__snippet">mergeTrackingAttributes</code> method to handle this. Therefore, we need to pass in both the existing tracking attributes plus any parent tracking attributes so that the two can be merged by that method.</ul></ul><li class=content__block_li><p class="font_size_body main__text">Lines 34 - 53: <code class="font_size_body code__snippet">mergeTrackingAttributes</code> method.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Lines 35 - 37: Take in the existing tracking attributes, plus any parent tracking attributes, confirm that each are in array form, and then create an empty array where each of their values will be staged in order prior to setting them in the current element’s appropriate tracking attributes.<li class=content__block_li><p class="font_size_body main__text">Lines 39 - 47: Declare the <code class="font_size_body code__snippet">mergedTrackingAttributesArrPusher</code> function, which will deduplicate the values as they are merged. Note that this function references the <code class="font_size_body code__snippet">uniqueValue</code> method for this purpose, which is declared on Lines 27 - 33.<li class=content__block_li><p class="font_size_body main__text">Line 49: The parent tracking attributes are deduplicated and staged first, since they should be at the front of the final concatenation.<li class=content__block_li><p class="font_size_body main__text">Line 50: The existing tracking attributes are deduplicated and staged second, since they should be at the end of the final concatenation.<li class=content__block_li><p class="font_size_body main__text">Line 52: All tracking values have now been deduplicated and staged into the array in the order we’ll want them concatenated for Analytics. Which means we’re ready to rewrite the current element’s tracking attributes in this order. This will be done by passing this array into the <code class="font_size_body code__snippet">setTrackingAttributes</code> method.</ul><li class=content__block_li><p class="font_size_body main__text">Lines 2 - 26: <code class="font_size_body code__snippet">setTrackingAttributes</code> method. This is where the ultimate purpose of this rule is achieved. Now that all parent tracking attributes and existing tracking attributes have been collected, deduplicated, and staged in the order that they should be concatenated for Analytics upon the user’s click, it is time to populate those values into the appropriate data attributes within the current element. To prevent unintended results, all tracking attributes get overwritten.<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Lines 7 - 9: This code block handles a very specific use case. I discovered times when an AEM Component contained only the <code class="font_size_body code__snippet">data-track-noun</code> attribute. This meant that it was the only value to be collected and “merged,” and would be placed in <code class="font_size_body code__snippet">data-track-verb</code> at this stage — resulting in both <code class="font_size_body code__snippet">data-track-noun</code> and <code class="font_size_body code__snippet">data-track-verb</code> having the same value. When clicked, the same value would be concatenated with each other. To prevent this, if only one value is going to be set, we first actively remove the <code class="font_size_body code__snippet">data-track-noun</code> attribute from the current element.<li class=content__block_li><p class="font_size_body main__text">Lines 11 - 22: Take the array of merged attributes and set them into the appropriate data attributes:<ul class="font_size_body main__list"><li class=content__block_li><p class="font_size_body main__text">Lines 13 - 15: The last value in the array gets set to <code class="font_size_body code__snippet">data-track-verb</code>.<li class=content__block_li><p class="font_size_body main__text">Lines 16 - 18: The second-to-last value in the array gets set to <code class="font_size_body code__snippet">data-track-noun</code>. (We have to work a bit backward in this manner because we don’t know how many items will be in the array.)<li class=content__block_li><p class="font_size_body main__text">Lines 19 - 20: If there are more than two items in the array, now we start from the front and set them into <code class="font_size_body code__snippet">data-track-component-level-X</code> (whichever number <code class="font_size_body code__snippet">X</code> is for this item — the index number plus 1).</ul><li class=content__block_li><p class="font_size_body main__text">Line 23: Set the <code class="font_size_body code__snippet">data-track-component-attributes-set</code> attribute to <code class="font_size_body code__snippet">"true"</code>. This is the flag that will prevent us from running all this same logic again if the page needs to be crawled more than once.<li class=content__block_li><p class="font_size_body main__text">Line 25: And now that we’ve handled this element, it’s time to repeat this entire process on each of <em>its</em> children. So we invoke <code class="font_size_body code__snippet">checkChildren</code> once again, and this time we <em>do</em> have merged tracking attributes to pass into it. Conveniently, they are already in the <code class="font_size_body code__snippet">mergedTrackingAttributesArr</code> array, so there is no need to scrape them out of the current element all over again — we just pass that array into the <code class="font_size_body code__snippet">checkChildren</code> method.</ul></ul><p class="font_size_body main__text">Once the end is reached and there are no more children to check, the rule stops. All AEM Components are now prepped for our <code class=code__name>Global | Set Variables | Clicks or Events #25</code> rule to pull from when the user clicks one. See my <a class="link link_theme_black" href=adobe-launch-global-clicks-or-events-tracking>Adobe Launch Global Clicks or Events Tracking article</a> for details on how that rule takes it from here.</div></div></section></main><footer class="footer footer_theme_black"><div class="content__center content__center_1140"><div class=footer__icon-row><div class=footer__icon><a class=footer__icon_link href=/ ><div class=footer__icon_link-content><i class="fas fa-home footer__icon_icon"></i><p class="font_size_body footer__icon_text">Home</div></a></div><div class=footer__icon><a class=footer__icon_link href=https://www.github.com/toddcf target=_blank><div class=footer__icon_link-content><i class="footer__icon_icon fab fa-github"></i><p class="font_size_body footer__icon_text">GitHub</div></a></div><div class=footer__icon><a class=footer__icon_link href=https://www.linkedin.com/in/toddcf target=_blank><div class=footer__icon_link-content><i class="footer__icon_icon fab fa-linkedin"></i><p class="font_size_body footer__icon_text">LinkedIn</div></a></div><div class=footer__icon><a class=footer__icon_link href=resume_todd_croak-falen.pdf target=_blank><div class=footer__icon_link-content><i class="fas footer__icon_icon fa-file-alt"></i><p class="font_size_body footer__icon_text">Résumé<p class="font_size_body footer__icon_text">(PDF with contact info)</div></a></div></div><div class=footer__copyright><p class="font_size_body footer__copyright_text">© Copyright 2016 <span class=currentYear></span>Todd Croak-Falen</div></div></footer></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js crossorigin=anonymous integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo></script><script src=../assets/js/jquery.waypoints.min.js></script><script src=../assets/prism/prism-okaidia-1.29.0.js></script><script src=../assets/js/global.js></script><script src=../assets/js/footer-min.js></script>